// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/traefik/traefik/v2/pkg/config/dynamic

package dynamic

import (
	"github.com/traefik/traefik/v2/pkg/types"
	traefiktls "github.com/traefik/traefik/v2/pkg/tls"
)

// HTTPConfiguration contains all the HTTP configuration parameters.
#HTTPConfiguration: {
	routers?: {[string]: null | #Router} @go(Routers,map[string]*Router) @toml(routers,omitempty)
	services?: {[string]: null | #Service} @go(Services,map[string]*Service) @toml(services,omitempty)
	middlewares?: {[string]: null | #Middleware} @go(Middlewares,map[string]*Middleware) @toml(middlewares,omitempty)
	models?: {[string]: null | #Model} @go(Models,map[string]*Model) @toml(models,omitempty)
	serversTransports?: {[string]: null | #ServersTransport} @go(ServersTransports,map[string]*ServersTransport) @toml(serversTransports,omitempty)
}

// Model is a set of default router's values.
#Model: {
	middlewares?: [...string] @go(Middlewares,[]string) @toml(middlewares,omitempty)
	tls?: null | #RouterTLSConfig @go(TLS,*RouterTLSConfig) @toml(tls,omitempty)
}

// Service holds a service configuration (can only be of one type at the same time).
#Service: {
	loadBalancer?: null | #ServersLoadBalancer @go(LoadBalancer,*ServersLoadBalancer) @toml(loadBalancer,omitempty)
	weighted?:     null | #WeightedRoundRobin  @go(Weighted,*WeightedRoundRobin) @toml(weighted,omitempty)
	mirroring?:    null | #Mirroring           @go(Mirroring,*Mirroring) @toml(mirroring,omitempty)
	failover?:     null | #Failover            @go(Failover,*Failover) @toml(failover,omitempty)
}

// Router holds the router configuration.
#Router: {
	entryPoints?: [...string] @go(EntryPoints,[]string) @toml(entryPoints,omitempty)
	middlewares?: [...string] @go(Middlewares,[]string) @toml(middlewares,omitempty)
	service?:  string                  @go(Service) @toml(service,omitempty)
	rule?:     string                  @go(Rule) @toml(rule,omitempty)
	priority?: int                     @go(Priority) @toml(priority,omitempty,omitzero)
	tls?:      null | #RouterTLSConfig @go(TLS,*RouterTLSConfig) @toml(tls,omitempty)
}

// RouterTLSConfig holds the TLS configuration for a router.
#RouterTLSConfig: {
	options?:      string @go(Options) @toml(options,omitempty)
	certResolver?: string @go(CertResolver) @toml(certResolver,omitempty)
	domains?: [...types.#Domain] @go(Domains,[]types.Domain) @toml(domains,omitempty)
}

// Mirroring holds the Mirroring configuration.
#Mirroring: {
	service?:     string       @go(Service) @toml(service,omitempty)
	maxBodySize?: null | int64 @go(MaxBodySize,*int64) @toml(maxBodySize,omitempty)
	mirrors?: [...#MirrorService] @go(Mirrors,[]MirrorService) @toml(mirrors,omitempty)
	healthCheck?: null | #HealthCheck @go(HealthCheck,*HealthCheck) @toml(healthCheck,omitempty)
}

// Failover holds the Failover configuration.
#Failover: {
	service?:     string              @go(Service) @toml(service,omitempty)
	fallback?:    string              @go(Fallback) @toml(fallback,omitempty)
	healthCheck?: null | #HealthCheck @go(HealthCheck,*HealthCheck) @toml(healthCheck,omitempty)
}

// MirrorService holds the MirrorService configuration.
#MirrorService: {
	name?:    string @go(Name) @toml(name,omitempty)
	percent?: int    @go(Percent) @toml(percent,omitempty)
}

// WeightedRoundRobin is a weighted round robin load-balancer of services.
#WeightedRoundRobin: {
	services?: [...#WRRService] @go(Services,[]WRRService) @toml(services,omitempty)
	sticky?: null | #Sticky @go(Sticky,*Sticky) @toml(sticky,omitempty)

	// HealthCheck enables automatic self-healthcheck for this service, i.e.
	// whenever one of its children is reported as down, this service becomes aware of it,
	// and takes it into account (i.e. it ignores the down child) when running the
	// load-balancing algorithm. In addition, if the parent of this service also has
	// HealthCheck enabled, this service reports to its parent any status change.
	healthCheck?: null | #HealthCheck @go(HealthCheck,*HealthCheck) @toml(healthCheck,omitempty)
}

// WRRService is a reference to a service load-balanced with weighted round-robin.
#WRRService: {
	name?:   string     @go(Name) @toml(name,omitempty)
	weight?: null | int @go(Weight,*int) @toml(weight,omitempty)
}

// Sticky holds the sticky configuration.
#Sticky: {
	// Cookie defines the sticky cookie configuration.
	cookie?: null | #Cookie @go(Cookie,*Cookie) @toml(cookie,omitempty)
}

// Cookie holds the sticky configuration based on cookie.
#Cookie: {
	// Name defines the Cookie name.
	name?: string @go(Name) @toml(name,omitempty)

	// Secure defines whether the cookie can only be transmitted over an encrypted connection (i.e. HTTPS).
	secure?: bool @go(Secure) @toml(secure,omitempty)

	// HTTPOnly defines whether the cookie can be accessed by client-side APIs, such as JavaScript.
	httpOnly?: bool @go(HTTPOnly) @toml(httpOnly,omitempty)

	// SameSite defines the same site policy.
	// More info: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite
	sameSite?: string @go(SameSite) @toml(sameSite,omitempty)
}

// ServersLoadBalancer holds the ServersLoadBalancer configuration.
#ServersLoadBalancer: {
	sticky?: null | #Sticky @go(Sticky,*Sticky) @toml(sticky,omitempty)
	servers?: [...#Server] @go(Servers,[]Server) @toml(servers,omitempty)

	// HealthCheck enables regular active checks of the responsiveness of the
	// children servers of this load-balancer. To propagate status changes (e.g. all
	// servers of this service are down) upwards, HealthCheck must also be enabled on
	// the parent(s) of this service.
	healthCheck?:        null | #ServerHealthCheck  @go(HealthCheck,*ServerHealthCheck) @toml(healthCheck,omitempty)
	passHostHeader?:     null | bool                @go(PassHostHeader,*bool) @toml(passHostHeader)
	responseForwarding?: null | #ResponseForwarding @go(ResponseForwarding,*ResponseForwarding) @toml(responseForwarding,omitempty)
	serversTransport?:   string                     @go(ServersTransport) @toml(serversTransport,omitempty)
}

// ResponseForwarding holds the response forwarding configuration.
#ResponseForwarding: {
	// FlushInterval defines the interval, in milliseconds, in between flushes to the client while copying the response body.
	// A negative value means to flush immediately after each write to the client.
	// This configuration is ignored when ReverseProxy recognizes a response as a streaming response;
	// for such responses, writes are flushed to the client immediately.
	// Default: 100ms
	flushInterval?: string @go(FlushInterval) @toml(flushInterval,omitempty)
}

// Server holds the server configuration.
#Server: {
	url?: string @go(URL) @toml(url,omitempty)
}

// ServerHealthCheck holds the HealthCheck configuration.
#ServerHealthCheck: {
	scheme?: string @go(Scheme) @toml(scheme,omitempty)
	path?:   string @go(Path) @toml(path,omitempty)
	method?: string @go(Method) @toml(method,omitempty)
	port?:   int    @go(Port) @toml(port,omitempty,omitzero)

	// TODO change string to ptypes.Duration
	interval?: string @go(Interval) @toml(interval,omitempty)

	// TODO change string to ptypes.Duration
	timeout?:         string      @go(Timeout) @toml(timeout,omitempty)
	hostname?:        string      @go(Hostname) @toml(hostname,omitempty)
	followRedirects?: null | bool @go(FollowRedirects,*bool) @toml(followRedirects)
	headers?: {[string]: string} @go(Headers,map[string]string) @toml(headers,omitempty)
}

// HealthCheck controls healthcheck awareness and propagation at the services level.
#HealthCheck: {
}

// ServersTransport options to configure communication between Traefik and the servers.
#ServersTransport: {
	serverName?:         string @go(ServerName) @toml(serverName,omitempty)
	insecureSkipVerify?: bool   @go(InsecureSkipVerify) @toml(insecureSkipVerify,omitempty)
	rootCAs?: [...traefiktls.#FileOrContent] @go(RootCAs,[]traefiktls.FileOrContent) @toml(rootCAs,omitempty)
	certificates?:        traefiktls.#Certificates @go(Certificates) @toml(certificates,omitempty)
	maxIdleConnsPerHost?: int                      @go(MaxIdleConnsPerHost) @toml(maxIdleConnsPerHost,omitempty)
	disableHTTP2?:        bool                     @go(DisableHTTP2) @toml(disableHTTP2,omitempty)
	peerCertURI?:         string                   @go(PeerCertURI) @toml(peerCertURI,omitempty)
}
