// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/traefik/traefik/v2/pkg/config/dynamic

package dynamic

import "github.com/traefik/traefik/v2/pkg/types"

// Middleware holds the Middleware configuration.
#Middleware: {
	addPrefix?:         null | #AddPrefix         @go(AddPrefix,*AddPrefix) @toml(addPrefix,omitempty)
	stripPrefix?:       null | #StripPrefix       @go(StripPrefix,*StripPrefix) @toml(stripPrefix,omitempty)
	stripPrefixRegex?:  null | #StripPrefixRegex  @go(StripPrefixRegex,*StripPrefixRegex) @toml(stripPrefixRegex,omitempty)
	replacePath?:       null | #ReplacePath       @go(ReplacePath,*ReplacePath) @toml(replacePath,omitempty)
	replacePathRegex?:  null | #ReplacePathRegex  @go(ReplacePathRegex,*ReplacePathRegex) @toml(replacePathRegex,omitempty)
	chain?:             null | #Chain             @go(Chain,*Chain) @toml(chain,omitempty)
	ipWhiteList?:       null | #IPWhiteList       @go(IPWhiteList,*IPWhiteList) @toml(ipWhiteList,omitempty)
	headers?:           null | #Headers           @go(Headers,*Headers) @toml(headers,omitempty)
	errors?:            null | #ErrorPage         @go(Errors,*ErrorPage) @toml(errors,omitempty)
	rateLimit?:         null | #RateLimit         @go(RateLimit,*RateLimit) @toml(rateLimit,omitempty)
	redirectRegex?:     null | #RedirectRegex     @go(RedirectRegex,*RedirectRegex) @toml(redirectRegex,omitempty)
	redirectScheme?:    null | #RedirectScheme    @go(RedirectScheme,*RedirectScheme) @toml(redirectScheme,omitempty)
	basicAuth?:         null | #BasicAuth         @go(BasicAuth,*BasicAuth) @toml(basicAuth,omitempty)
	digestAuth?:        null | #DigestAuth        @go(DigestAuth,*DigestAuth) @toml(digestAuth,omitempty)
	forwardAuth?:       null | #ForwardAuth       @go(ForwardAuth,*ForwardAuth) @toml(forwardAuth,omitempty)
	inFlightReq?:       null | #InFlightReq       @go(InFlightReq,*InFlightReq) @toml(inFlightReq,omitempty)
	buffering?:         null | #Buffering         @go(Buffering,*Buffering) @toml(buffering,omitempty)
	circuitBreaker?:    null | #CircuitBreaker    @go(CircuitBreaker,*CircuitBreaker) @toml(circuitBreaker,omitempty)
	compress?:          null | #Compress          @go(Compress,*Compress) @toml(compress,omitempty)
	passTLSClientCert?: null | #PassTLSClientCert @go(PassTLSClientCert,*PassTLSClientCert) @toml(passTLSClientCert,omitempty)
	retry?:             null | #Retry             @go(Retry,*Retry) @toml(retry,omitempty)
	contentType?:       null | #ContentType       @go(ContentType,*ContentType) @toml(contentType,omitempty)
	plugin?: {[string]: #PluginConf} @go(Plugin,map[string]PluginConf) @toml(plugin,omitempty)
}

// ContentType holds the content-type middleware configuration.
// This middleware exists to enable the correct behavior until at least the default one can be changed in a future version.
#ContentType: {
	// AutoDetect specifies whether to let the `Content-Type` header, if it has not been set by the backend,
	// be automatically set to a value derived from the contents of the response.
	// As a proxy, the default behavior should be to leave the header alone, regardless of what the backend did with it.
	// However, the historic default was to always auto-detect and set the header if it was nil,
	// and it is going to be kept that way in order to support users currently relying on it.
	autoDetect?: bool @go(AutoDetect) @toml(autoDetect,omitempty)
}

// AddPrefix holds the add prefix middleware configuration.
// This middleware updates the path of a request before forwarding it.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/addprefix/
#AddPrefix: {
	// Prefix is the string to add before the current path in the requested URL.
	// It should include a leading slash (/).
	prefix?: string @go(Prefix) @toml(prefix,omitempty)
}

// BasicAuth holds the basic auth middleware configuration.
// This middleware restricts access to your services to known users.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/basicauth/
#BasicAuth: {
	// Users is an array of authorized users.
	// Each user must be declared using the name:hashed-password format.
	// Tip: Use htpasswd to generate the passwords.
	users?: #Users @go(Users) @toml(users,omitempty)

	// UsersFile is the path to an external file that contains the authorized users.
	usersFile?: string @go(UsersFile) @toml(usersFile,omitempty)

	// Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
	// Default: traefik.
	realm?: string @go(Realm) @toml(realm,omitempty)

	// RemoveHeader sets the removeHeader option to true to remove the authorization header before forwarding the request to your service.
	// Default: false.
	removeHeader?: bool @go(RemoveHeader) @toml(removeHeader,omitempty)

	// HeaderField defines a header field to store the authenticated user.
	// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/basicauth/#headerfield
	headerField?: string @go(HeaderField) @toml(headerField,omitempty)
}

// Buffering holds the buffering middleware configuration.
// This middleware retries or limits the size of requests that can be forwarded to backends.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/buffering/#maxrequestbodybytes
#Buffering: {
	// MaxRequestBodyBytes defines the maximum allowed body size for the request (in bytes).
	// If the request exceeds the allowed size, it is not forwarded to the service, and the client gets a 413 (Request Entity Too Large) response.
	// Default: 0 (no maximum).
	maxRequestBodyBytes?: int64 @go(MaxRequestBodyBytes) @toml(maxRequestBodyBytes,omitempty)

	// MemRequestBodyBytes defines the threshold (in bytes) from which the request will be buffered on disk instead of in memory.
	// Default: 1048576 (1Mi).
	memRequestBodyBytes?: int64 @go(MemRequestBodyBytes) @toml(memRequestBodyBytes,omitempty)

	// MaxResponseBodyBytes defines the maximum allowed response size from the service (in bytes).
	// If the response exceeds the allowed size, it is not forwarded to the client. The client gets a 500 (Internal Server Error) response instead.
	// Default: 0 (no maximum).
	maxResponseBodyBytes?: int64 @go(MaxResponseBodyBytes) @toml(maxResponseBodyBytes,omitempty)

	// MemResponseBodyBytes defines the threshold (in bytes) from which the response will be buffered on disk instead of in memory.
	// Default: 1048576 (1Mi).
	memResponseBodyBytes?: int64 @go(MemResponseBodyBytes) @toml(memResponseBodyBytes,omitempty)

	// RetryExpression defines the retry conditions.
	// It is a logical combination of functions with operators AND (&&) and OR (||).
	// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/buffering/#retryexpression
	retryExpression?: string @go(RetryExpression) @toml(retryExpression,omitempty)
}

// Chain holds the chain middleware configuration.
// This middleware enables to define reusable combinations of other pieces of middleware.
#Chain: {
	// Middlewares is the list of middleware names which composes the chain.
	middlewares?: [...string] @go(Middlewares,[]string) @toml(middlewares,omitempty)
}

// CircuitBreaker holds the circuit breaker middleware configuration.
// This middleware protects the system from stacking requests to unhealthy services, resulting in cascading failures.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/circuitbreaker/
#CircuitBreaker: {
	// Expression defines the expression that, once matched, opens the circuit breaker and applies the fallback mechanism instead of calling the services.
	expression?: string @go(Expression) @toml(expression,omitempty)
}

// Compress holds the compress middleware configuration.
// This middleware compresses responses before sending them to the client, using gzip compression.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/compress/
#Compress: {
	// ExcludedContentTypes defines the list of content types to compare the Content-Type header of the incoming requests and responses before compressing.
	excludedContentTypes?: [...string] @go(ExcludedContentTypes,[]string) @toml(excludedContentTypes,omitempty)

	// MinResponseBodyBytes defines the minimum amount of bytes a response body must have to be compressed.
	// Default: 1024.
	minResponseBodyBytes?: int @go(MinResponseBodyBytes) @toml(minResponseBodyBytes,omitempty)
}

// DigestAuth holds the digest auth middleware configuration.
// This middleware restricts access to your services to known users.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/digestauth/
#DigestAuth: {
	// Users defines the authorized users.
	// Each user should be declared using the name:realm:encoded-password format.
	users?: #Users @go(Users) @toml(users,omitempty)

	// UsersFile is the path to an external file that contains the authorized users for the middleware.
	usersFile?: string @go(UsersFile) @toml(usersFile,omitempty)

	// RemoveHeader defines whether to remove the authorization header before forwarding the request to the backend.
	removeHeader?: bool @go(RemoveHeader) @toml(removeHeader,omitempty)

	// Realm allows the protected resources on a server to be partitioned into a set of protection spaces, each with its own authentication scheme.
	// Default: traefik.
	realm?: string @go(Realm) @toml(realm,omitempty)

	// HeaderField defines a header field to store the authenticated user.
	// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/basicauth/#headerfield
	headerField?: string @go(HeaderField) @toml(headerField,omitempty)
}

// ErrorPage holds the custom error middleware configuration.
// This middleware returns a custom page in lieu of the default, according to configured ranges of HTTP Status codes.
#ErrorPage: {
	// Status defines which status or range of statuses should result in an error page.
	// It can be either a status code as a number (500),
	// as multiple comma-separated numbers (500,502),
	// as ranges by separating two codes with a dash (500-599),
	// or a combination of the two (404,418,500-599).
	status?: [...string] @go(Status,[]string) @toml(status,omitempty)

	// Service defines the name of the service that will serve the error page.
	service?: string @go(Service) @toml(service,omitempty)

	// Query defines the URL for the error page (hosted by service).
	// The {status} variable can be used in order to insert the status code in the URL.
	query?: string @go(Query) @toml(query,omitempty)
}

// ForwardAuth holds the forward auth middleware configuration.
// This middleware delegates the request authentication to a Service.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/forwardauth/
#ForwardAuth: {
	// Address defines the authentication server address.
	address?: string @go(Address) @toml(address,omitempty)

	// TLS defines the configuration used to secure the connection to the authentication server.
	tls?: null | types.#ClientTLS @go(TLS,*types.ClientTLS) @toml(tls,omitempty)

	// TrustForwardHeader defines whether to trust (ie: forward) all X-Forwarded-* headers.
	trustForwardHeader?: bool @go(TrustForwardHeader) @toml(trustForwardHeader,omitempty)

	// AuthResponseHeaders defines the list of headers to copy from the authentication server response and set on forwarded request, replacing any existing conflicting headers.
	authResponseHeaders?: [...string] @go(AuthResponseHeaders,[]string) @toml(authResponseHeaders,omitempty)

	// AuthResponseHeadersRegex defines the regex to match headers to copy from the authentication server response and set on forwarded request, after stripping all headers that match the regex.
	// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/forwardauth/#authresponseheadersregex
	authResponseHeadersRegex?: string @go(AuthResponseHeadersRegex) @toml(authResponseHeadersRegex,omitempty)

	// AuthRequestHeaders defines the list of the headers to copy from the request to the authentication server.
	// If not set or empty then all request headers are passed.
	authRequestHeaders?: [...string] @go(AuthRequestHeaders,[]string) @toml(authRequestHeaders,omitempty)
}

// Headers holds the headers middleware configuration.
// This middleware manages the requests and responses headers.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/headers/#customrequestheaders
#Headers: {
	// CustomRequestHeaders defines the header names and values to apply to the request.
	customRequestHeaders?: {[string]: string} @go(CustomRequestHeaders,map[string]string) @toml(customRequestHeaders,omitempty)

	// CustomResponseHeaders defines the header names and values to apply to the response.
	customResponseHeaders?: {[string]: string} @go(CustomResponseHeaders,map[string]string) @toml(customResponseHeaders,omitempty)

	// AccessControlAllowCredentials defines whether the request can include user credentials.
	accessControlAllowCredentials?: bool @go(AccessControlAllowCredentials) @toml(accessControlAllowCredentials,omitempty)

	// AccessControlAllowHeaders defines the Access-Control-Request-Headers values sent in preflight response.
	accessControlAllowHeaders?: [...string] @go(AccessControlAllowHeaders,[]string) @toml(accessControlAllowHeaders,omitempty)

	// AccessControlAllowMethods defines the Access-Control-Request-Method values sent in preflight response.
	accessControlAllowMethods?: [...string] @go(AccessControlAllowMethods,[]string) @toml(accessControlAllowMethods,omitempty)

	// AccessControlAllowOriginList is a list of allowable origins. Can also be a wildcard origin "*".
	accessControlAllowOriginList?: [...string] @go(AccessControlAllowOriginList,[]string) @toml(accessControlAllowOriginList,omitempty)

	// AccessControlAllowOriginListRegex is a list of allowable origins written following the Regular Expression syntax (https://golang.org/pkg/regexp/).
	accessControlAllowOriginListRegex?: [...string] @go(AccessControlAllowOriginListRegex,[]string) @toml(accessControlAllowOriginListRegex,omitempty)

	// AccessControlExposeHeaders defines the Access-Control-Expose-Headers values sent in preflight response.
	accessControlExposeHeaders?: [...string] @go(AccessControlExposeHeaders,[]string) @toml(accessControlExposeHeaders,omitempty)

	// AccessControlMaxAge defines the time that a preflight request may be cached.
	accessControlMaxAge?: int64 @go(AccessControlMaxAge) @toml(accessControlMaxAge,omitempty)

	// AddVaryHeader defines whether the Vary header is automatically added/updated when the AccessControlAllowOriginList is set.
	addVaryHeader?: bool @go(AddVaryHeader) @toml(addVaryHeader,omitempty)

	// AllowedHosts defines the fully qualified list of allowed domain names.
	allowedHosts?: [...string] @go(AllowedHosts,[]string) @toml(allowedHosts,omitempty)

	// HostsProxyHeaders defines the header keys that may hold a proxied hostname value for the request.
	hostsProxyHeaders?: [...string] @go(HostsProxyHeaders,[]string) @toml(hostsProxyHeaders,omitempty)

	// Deprecated: use EntryPoint redirection or RedirectScheme instead.
	sslRedirect?: bool @go(SSLRedirect) @toml(sslRedirect,omitempty)

	// Deprecated: use EntryPoint redirection or RedirectScheme instead.
	sslTemporaryRedirect?: bool @go(SSLTemporaryRedirect) @toml(sslTemporaryRedirect,omitempty)

	// Deprecated: use RedirectRegex instead.
	sslHost?: string @go(SSLHost) @toml(sslHost,omitempty)

	// SSLProxyHeaders defines the header keys with associated values that would indicate a valid HTTPS request.
	// It can be useful when using other proxies (example: "X-Forwarded-Proto": "https").
	sslProxyHeaders?: {[string]: string} @go(SSLProxyHeaders,map[string]string) @toml(sslProxyHeaders,omitempty)

	// Deprecated: use RedirectRegex instead.
	sslForceHost?: bool @go(SSLForceHost) @toml(sslForceHost,omitempty)

	// STSSeconds defines the max-age of the Strict-Transport-Security header.
	// If set to 0, the header is not set.
	stsSeconds?: int64 @go(STSSeconds) @toml(stsSeconds,omitempty)

	// STSIncludeSubdomains defines whether the includeSubDomains directive is appended to the Strict-Transport-Security header.
	stsIncludeSubdomains?: bool @go(STSIncludeSubdomains) @toml(stsIncludeSubdomains,omitempty)

	// STSPreload defines whether the preload flag is appended to the Strict-Transport-Security header.
	stsPreload?: bool @go(STSPreload) @toml(stsPreload,omitempty)

	// ForceSTSHeader defines whether to add the STS header even when the connection is HTTP.
	forceSTSHeader?: bool @go(ForceSTSHeader) @toml(forceSTSHeader,omitempty)

	// FrameDeny defines whether to add the X-Frame-Options header with the DENY value.
	frameDeny?: bool @go(FrameDeny) @toml(frameDeny,omitempty)

	// CustomFrameOptionsValue defines the X-Frame-Options header value.
	// This overrides the FrameDeny option.
	customFrameOptionsValue?: string @go(CustomFrameOptionsValue) @toml(customFrameOptionsValue,omitempty)

	// ContentTypeNosniff defines whether to add the X-Content-Type-Options header with the nosniff value.
	contentTypeNosniff?: bool @go(ContentTypeNosniff) @toml(contentTypeNosniff,omitempty)

	// BrowserXSSFilter defines whether to add the X-XSS-Protection header with the value 1; mode=block.
	browserXssFilter?: bool @go(BrowserXSSFilter) @toml(browserXssFilter,omitempty)

	// CustomBrowserXSSValue defines the X-XSS-Protection header value.
	// This overrides the BrowserXssFilter option.
	customBrowserXSSValue?: string @go(CustomBrowserXSSValue) @toml(customBrowserXSSValue,omitempty)

	// ContentSecurityPolicy defines the Content-Security-Policy header value.
	contentSecurityPolicy?: string @go(ContentSecurityPolicy) @toml(contentSecurityPolicy,omitempty)

	// PublicKey is the public key that implements HPKP to prevent MITM attacks with forged certificates.
	publicKey?: string @go(PublicKey) @toml(publicKey,omitempty)

	// ReferrerPolicy defines the Referrer-Policy header value.
	// This allows sites to control whether browsers forward the Referer header to other sites.
	referrerPolicy?: string @go(ReferrerPolicy) @toml(referrerPolicy,omitempty)

	// Deprecated: use PermissionsPolicy instead.
	featurePolicy?: string @go(FeaturePolicy) @toml(featurePolicy,omitempty)

	// PermissionsPolicy defines the Permissions-Policy header value.
	// This allows sites to control browser features.
	permissionsPolicy?: string @go(PermissionsPolicy) @toml(permissionsPolicy,omitempty)

	// IsDevelopment defines whether to mitigate the unwanted effects of the AllowedHosts, SSL, and STS options when developing.
	// Usually testing takes place using HTTP, not HTTPS, and on localhost, not your production domain.
	// If you would like your development environment to mimic production with complete Host blocking, SSL redirects,
	// and STS headers, leave this as false.
	isDevelopment?: bool @go(IsDevelopment) @toml(isDevelopment,omitempty)
}

// IPStrategy holds the IP strategy configuration used by Traefik to determine the client IP.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/ipwhitelist/#ipstrategy
#IPStrategy: {
	// Depth tells Traefik to use the X-Forwarded-For header and take the IP located at the depth position (starting from the right).
	depth?: int @go(Depth) @toml(depth,omitempty)

	// ExcludedIPs configures Traefik to scan the X-Forwarded-For header and select the first IP not in the list.
	excludedIPs?: [...string] @go(ExcludedIPs,[]string) @toml(excludedIPs,omitempty)
}

// IPWhiteList holds the IP whitelist middleware configuration.
// This middleware accepts / refuses requests based on the client IP.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/ipwhitelist/
#IPWhiteList: {
	// SourceRange defines the set of allowed IPs (or ranges of allowed IPs by using CIDR notation).
	sourceRange?: [...string] @go(SourceRange,[]string) @toml(sourceRange,omitempty)
	ipStrategy?: null | #IPStrategy @go(IPStrategy,*IPStrategy) @toml(ipStrategy,omitempty)
}

// InFlightReq holds the in-flight request middleware configuration.
// This middleware limits the number of requests being processed and served concurrently.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/inflightreq/
#InFlightReq: {
	// Amount defines the maximum amount of allowed simultaneous in-flight request.
	// The middleware responds with HTTP 429 Too Many Requests if there are already amount requests in progress (based on the same sourceCriterion strategy).
	amount?: int64 @go(Amount) @toml(amount,omitempty)

	// SourceCriterion defines what criterion is used to group requests as originating from a common source.
	// If several strategies are defined at the same time, an error will be raised.
	// If none are set, the default is to use the requestHost.
	// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/inflightreq/#sourcecriterion
	sourceCriterion?: null | #SourceCriterion @go(SourceCriterion,*SourceCriterion) @toml(sourceCriterion,omitempty)
}

// PassTLSClientCert holds the pass TLS client cert middleware configuration.
// This middleware adds the selected data from the passed client TLS certificate to a header.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/passtlsclientcert/
#PassTLSClientCert: {
	// PEM sets the X-Forwarded-Tls-Client-Cert header with the certificate.
	pem?: bool @go(PEM) @toml(pem,omitempty)

	// Info selects the specific client certificate details you want to add to the X-Forwarded-Tls-Client-Cert-Info header.
	info?: null | #TLSClientCertificateInfo @go(Info,*TLSClientCertificateInfo) @toml(info,omitempty)
}

// SourceCriterion defines what criterion is used to group requests as originating from a common source.
// If none are set, the default is to use the request's remote address field.
// All fields are mutually exclusive.
#SourceCriterion: {
	ipStrategy?: null | #IPStrategy @go(IPStrategy,*IPStrategy) @toml(ipStrategy,omitempty)

	// RequestHeaderName defines the name of the header used to group incoming requests.
	requestHeaderName?: string @go(RequestHeaderName) @toml(requestHeaderName,omitempty)

	// RequestHost defines whether to consider the request Host as the source.
	requestHost?: bool @go(RequestHost) @toml(requestHost,omitempty)
}

// RateLimit holds the rate limit configuration.
// This middleware ensures that services will receive a fair amount of requests, and allows one to define what fair is.
#RateLimit: {
	// Average is the maximum rate, by default in requests/s, allowed for the given source.
	// It defaults to 0, which means no rate limiting.
	// The rate is actually defined by dividing Average by Period. So for a rate below 1req/s,
	// one needs to define a Period larger than a second.
	average?: int64 @go(Average) @toml(average,omitempty)

	// Burst is the maximum number of requests allowed to arrive in the same arbitrarily small period of time.
	// It defaults to 1.
	burst?: int64 @go(Burst) @toml(burst,omitempty)

	// SourceCriterion defines what criterion is used to group requests as originating from a common source.
	// If several strategies are defined at the same time, an error will be raised.
	// If none are set, the default is to use the request's remote address field (as an ipStrategy).
	sourceCriterion?: null | #SourceCriterion @go(SourceCriterion,*SourceCriterion) @toml(sourceCriterion,omitempty)
}

// RedirectRegex holds the redirect regex middleware configuration.
// This middleware redirects a request using regex matching and replacement.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/redirectregex/#regex
#RedirectRegex: {
	// Regex defines the regex used to match and capture elements from the request URL.
	regex?: string @go(Regex) @toml(regex,omitempty)

	// Replacement defines how to modify the URL to have the new target URL.
	replacement?: string @go(Replacement) @toml(replacement,omitempty)

	// Permanent defines whether the redirection is permanent (301).
	permanent?: bool @go(Permanent) @toml(permanent,omitempty)
}

// RedirectScheme holds the redirect scheme middleware configuration.
// This middleware redirects requests from a scheme/port to another.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/redirectscheme/
#RedirectScheme: {
	// Scheme defines the scheme of the new URL.
	scheme?: string @go(Scheme) @toml(scheme,omitempty)

	// Port defines the port of the new URL.
	port?: string @go(Port) @toml(port,omitempty)

	// Permanent defines whether the redirection is permanent (301).
	permanent?: bool @go(Permanent) @toml(permanent,omitempty)
}

// ReplacePath holds the replace path middleware configuration.
// This middleware replaces the path of the request URL and store the original path in an X-Replaced-Path header.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/replacepath/
#ReplacePath: {
	// Path defines the path to use as replacement in the request URL.
	path?: string @go(Path) @toml(path,omitempty)
}

// ReplacePathRegex holds the replace path regex middleware configuration.
// This middleware replaces the path of a URL using regex matching and replacement.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/replacepathregex/
#ReplacePathRegex: {
	// Regex defines the regular expression used to match and capture the path from the request URL.
	regex?: string @go(Regex) @toml(regex,omitempty)

	// Replacement defines the replacement path format, which can include captured variables.
	replacement?: string @go(Replacement) @toml(replacement,omitempty)
}

// Retry holds the retry middleware configuration.
// This middleware reissues requests a given number of times to a backend server if that server does not reply.
// As soon as the server answers, the middleware stops retrying, regardless of the response status.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/retry/
#Retry: {
	// Attempts defines how many times the request should be retried.
	attempts?: int @go(Attempts) @toml(attempts,omitempty)
}

// StripPrefix holds the strip prefix middleware configuration.
// This middleware removes the specified prefixes from the URL path.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/stripprefix/
#StripPrefix: {
	// Prefixes defines the prefixes to strip from the request URL.
	prefixes?: [...string] @go(Prefixes,[]string) @toml(prefixes,omitempty)

	// ForceSlash ensures that the resulting stripped path is not the empty string, by replacing it with / when necessary.
	// Default: true.
	forceSlash?: bool @go(ForceSlash) @toml(forceSlash,omitempty)
}

// StripPrefixRegex holds the strip prefix regex middleware configuration.
// This middleware removes the matching prefixes from the URL path.
// More info: https://doc.traefik.io/traefik/v2.9/middlewares/http/stripprefixregex/
#StripPrefixRegex: {
	// Regex defines the regular expression to match the path prefix from the request URL.
	regex?: [...string] @go(Regex,[]string) @toml(regex,omitempty)
}

// TLSClientCertificateInfo holds the client TLS certificate info configuration.
#TLSClientCertificateInfo: {
	// NotAfter defines whether to add the Not After information from the Validity part.
	notAfter?: bool @go(NotAfter) @toml(notAfter,omitempty)

	// NotBefore defines whether to add the Not Before information from the Validity part.
	notBefore?: bool @go(NotBefore) @toml(notBefore,omitempty)

	// Sans defines whether to add the Subject Alternative Name information from the Subject Alternative Name part.
	sans?: bool @go(Sans) @toml(sans,omitempty)

	// SerialNumber defines whether to add the client serialNumber information.
	serialNumber?: bool @go(SerialNumber) @toml(serialNumber,omitempty)

	// Subject defines the client certificate subject details to add to the X-Forwarded-Tls-Client-Cert-Info header.
	subject?: null | #TLSClientCertificateSubjectDNInfo @go(Subject,*TLSClientCertificateSubjectDNInfo) @toml(subject,omitempty)

	// Issuer defines the client certificate issuer details to add to the X-Forwarded-Tls-Client-Cert-Info header.
	issuer?: null | #TLSClientCertificateIssuerDNInfo @go(Issuer,*TLSClientCertificateIssuerDNInfo) @toml(issuer,omitempty)
}

// TLSClientCertificateIssuerDNInfo holds the client TLS certificate distinguished name info configuration.
// cf https://tools.ietf.org/html/rfc3739
#TLSClientCertificateIssuerDNInfo: {
	// Country defines whether to add the country information into the issuer.
	country?: bool @go(Country) @toml(country,omitempty)

	// Province defines whether to add the province information into the issuer.
	province?: bool @go(Province) @toml(province,omitempty)

	// Locality defines whether to add the locality information into the issuer.
	locality?: bool @go(Locality) @toml(locality,omitempty)

	// Organization defines whether to add the organization information into the issuer.
	organization?: bool @go(Organization) @toml(organization,omitempty)

	// CommonName defines whether to add the organizationalUnit information into the issuer.
	commonName?: bool @go(CommonName) @toml(commonName,omitempty)

	// SerialNumber defines whether to add the serialNumber information into the issuer.
	serialNumber?: bool @go(SerialNumber) @toml(serialNumber,omitempty)

	// DomainComponent defines whether to add the domainComponent information into the issuer.
	domainComponent?: bool @go(DomainComponent) @toml(domainComponent,omitempty)
}

// TLSClientCertificateSubjectDNInfo holds the client TLS certificate distinguished name info configuration.
// cf https://tools.ietf.org/html/rfc3739
#TLSClientCertificateSubjectDNInfo: {
	// Country defines whether to add the country information into the subject.
	country?: bool @go(Country) @toml(country,omitempty)

	// Province defines whether to add the province information into the subject.
	province?: bool @go(Province) @toml(province,omitempty)

	// Locality defines whether to add the locality information into the subject.
	locality?: bool @go(Locality) @toml(locality,omitempty)

	// Organization defines whether to add the organization information into the subject.
	organization?: bool @go(Organization) @toml(organization,omitempty)

	// OrganizationalUnit defines whether to add the organizationalUnit information into the subject.
	organizationalUnit?: bool @go(OrganizationalUnit) @toml(organizationalUnit,omitempty)

	// CommonName defines whether to add the organizationalUnit information into the subject.
	commonName?: bool @go(CommonName) @toml(commonName,omitempty)

	// SerialNumber defines whether to add the serialNumber information into the subject.
	serialNumber?: bool @go(SerialNumber) @toml(serialNumber,omitempty)

	// DomainComponent defines whether to add the domainComponent information into the subject.
	domainComponent?: bool @go(DomainComponent) @toml(domainComponent,omitempty)
}

// Users holds a list of users.
#Users: [...string]
